// Generated using `moon info`, DON'T EDIT IT
package "oboard/moonbit-eval/interpreter"

import(
  "moonbitlang/core/bigint"
  "moonbitlang/core/hashmap"
  "moonbitlang/core/json"
  "moonbitlang/core/list"
  "moonbitlang/parser/syntax"
)

// Values
pub let array_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

pub let array_view_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

pub let bytes_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

pub fn check_type_constraint2(RuntimeType, @syntax.Type) -> Bool

#callsite(autofill(loc))
pub fn[A] error(String, loc~ : SourceLoc) -> A raise ControlFlow

pub fn extract_type_name(@syntax.Type) -> String

pub let fixedarray_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

pub let fs_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

pub let fs_package : RuntimePackage

pub let hash_map_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

pub let int_embedded_code : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

pub let int_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

pub let iter2_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

pub let iter_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

pub fn load_package_dir(String, String) -> RuntimePackage?

pub fn manualUnescape(StringView, StringBuilder) -> Unit

pub let map_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

pub let option_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

pub fn parse_code_to_expr(String) -> Result[@syntax.Expr, String]

pub fn parse_code_to_impl(String) -> Result[@syntax.Impl, String]

pub fn runtime_value_infix(String, RuntimeValue, RuntimeValue) -> RuntimeValue

pub let string_embedded_code : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

pub fn type_to_string(@syntax.Type) -> String

// Errors
pub suberror ControlFlow {
  Raise(RuntimeValue)
  Continue(Array[RuntimeValue])
  Break(RuntimeValue)
  Return(RuntimeValue)
  Error(String)
}

// Types and methods
pub(all) struct ClosureInterpreter {
  extern_fns : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]
  embedded_fns : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]
  embedded_methods : Map[String, Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]]
  main_pkg : RuntimePackage
  mut current_pkg : RuntimePackage
  call_stack : Array[RuntimeLocation]
}
pub fn ClosureInterpreter::add_embedded_fn(Self, String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow) -> Unit
pub fn ClosureInterpreter::add_embedded_method(Self, String, String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow) -> Unit
pub fn ClosureInterpreter::add_extern_fn(Self, String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow) -> Unit
pub fn ClosureInterpreter::bind_function_parameters(Self, @list.List[@syntax.Parameter], @list.List[RuntimeArgument]) -> Unit raise ControlFlow
pub fn ClosureInterpreter::call(Self, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow, RuntimePackage, FixedArray[RuntimeArgument]) -> RuntimeValue raise ControlFlow
pub fn ClosureInterpreter::call_closure(Self, @syntax.Func, RuntimePackage, @list.List[@syntax.Argument], name? : String) -> RuntimeValue raise ControlFlow
pub fn ClosureInterpreter::constants_equal(Self, @syntax.Constant, @syntax.Constant) -> Bool
pub fn ClosureInterpreter::constants_equal_expr(Self, @syntax.Expr, @syntax.Expr) -> Bool
pub fn ClosureInterpreter::create_function(Self, @syntax.Func, RuntimePackage, name? : String) -> WithType[(RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]
pub fn ClosureInterpreter::define_struct_method(Self, RuntimePackage, String, String, @syntax.Func) -> Unit
pub fn[A] ClosureInterpreter::error(Self, String) -> A raise ControlFlow
pub fn ClosureInterpreter::find_pkg(Self, String) -> RuntimePackage
pub fn ClosureInterpreter::format_patterns(Self, @list.List[@syntax.Case]) -> String
pub fn ClosureInterpreter::get_function_type_string(Self, @syntax.Func) -> String
pub fn ClosureInterpreter::infer_pattern_type(Self, @syntax.Pattern) -> String?
pub fn ClosureInterpreter::interp_string(Self, @list.List[@syntax.InterpElem]) -> String raise ControlFlow
pub fn ClosureInterpreter::is_known_function(Self, String) -> Bool
pub fn ClosureInterpreter::load_module(Self, RuntimeModule) -> Unit
pub fn ClosureInterpreter::load_package(Self, RuntimePackage, target? : String) -> Unit
pub fn ClosureInterpreter::lookup_current_function(Self) -> String
pub fn ClosureInterpreter::match_case(Self, RuntimeValue, @syntax.Pattern) -> Bool
pub fn ClosureInterpreter::new() -> Self
pub fn ClosureInterpreter::parse_error_type(Self, @syntax.ErrorType) -> RuntimeErrorType
pub fn ClosureInterpreter::parse_type(Self, @syntax.Type) -> RuntimeType
pub fn ClosureInterpreter::pattern_match(Self, RuntimeValue, @list.List[@syntax.Case]) -> RuntimeValue raise ControlFlow
pub fn ClosureInterpreter::pattern_to_runtime_value(Self, @syntax.Pattern) -> RuntimeValue?
pub fn ClosureInterpreter::pop_scope(Self) -> Unit
pub fn ClosureInterpreter::push_scope(Self, RuntimeLocation) -> Unit
pub fn ClosureInterpreter::runtime_value_in_range(Self, RuntimeValue, @syntax.Pattern, @syntax.Pattern, @syntax.RangeKind) -> Bool
pub fn ClosureInterpreter::top_eval(Self, String) -> Unit
pub fn ClosureInterpreter::top_func_def_to_closure(Self, RuntimePackage, @syntax.Impl, name? : String) -> (String?, RuntimeValue)
pub fn ClosureInterpreter::top_visit(Self, @syntax.Impl) -> RuntimeValue
pub fn ClosureInterpreter::visit(Self, @syntax.Expr, expected_type? : String) -> RuntimeValue raise ControlFlow
pub fn ClosureInterpreter::visit_interp(Self, @list.List[@syntax.InterpElem]) -> RuntimeValue raise ControlFlow
pub fn ClosureInterpreter::visit_multiline_string(Self, @list.List[@syntax.MultilineStringElem]) -> RuntimeValue raise ControlFlow
pub fn ClosureInterpreter::visit_scoped(Self, @syntax.Expr, RuntimeLocation) -> RuntimeValue raise ControlFlow
pub fn[T] ClosureInterpreter::with_ident(Self, @syntax.LongIdent, (RuntimePackage, String) -> T raise?) -> T raise?

pub(all) struct ConstructorField {
  name : String?
  mut value : RuntimeValue
  mutable : Bool
}

pub(all) struct ConstructorValue {
  name : String
  fields : Array[ConstructorField]
}

pub(all) struct ModuleInfo {
  name : String
  version : String?
  deps : Map[String, String]?
  readme : String?
  repository : String?
  license : String?
  keywords : Array[String]?
  description : String?
  source : String?
}
pub fn ModuleInfo::get_zip_url(Self) -> String
pub fn ModuleInfo::new(String, version? : String, readme? : String, repository? : String, license? : String, keywords? : Array[String], description? : String, source? : String, deps? : Map[String, String]) -> Self
pub impl Show for ModuleInfo
pub impl ToJson for ModuleInfo
pub impl @json.FromJson for ModuleInfo

pub(all) struct RuntimeArgument {
  val : RuntimeValue
  kind : RuntimeArgumentKind
}

pub(all) enum RuntimeArgumentKind {
  Positional
  Labelled(String)
  LabelledOption(String)
}
pub fn RuntimeArgumentKind::from_syntax(@syntax.ArgumentKind) -> Self

pub(all) struct RuntimeEnvironment {
  values : Map[String, RuntimeValue]
  mutable_vars : Map[String, Bool]
  parent : RuntimeEnvironment?
}
pub fn RuntimeEnvironment::copy(Self) -> Self
pub fn RuntimeEnvironment::create_closure_env(Self) -> Self
pub fn RuntimeEnvironment::find(Self, String) -> RuntimeValue?
pub fn RuntimeEnvironment::new(parent? : Self, values? : Map[String, RuntimeValue]) -> Self
pub fn RuntimeEnvironment::set(Self, String, RuntimeValue) -> Unit
pub fn RuntimeEnvironment::set_mutable_variable(Self, String, RuntimeValue) -> Unit
pub fn RuntimeEnvironment::update(Self, String, RuntimeValue) -> Unit
pub impl ToJson for RuntimeEnvironment

pub(all) enum RuntimeErrorType {
  ErrorType(RuntimeType)
  DefaultErrorType
  NoErrorType
  Noraise
  MaybeError(RuntimeType)
}
pub impl Eq for RuntimeErrorType
pub impl Show for RuntimeErrorType
pub impl ToJson for RuntimeErrorType

pub(all) struct RuntimeFunctionContext {
  context : ClosureInterpreter
  pkg : RuntimePackage
  args : FixedArray[RuntimeArgument]
}
pub fn RuntimeFunctionContext::named(Self, String) -> RuntimeValue?

pub enum RuntimeLocation {
  FunctionCall(String)
  ControlFlow(String)
  LetMut(String)
}
pub impl Show for RuntimeLocation

pub(all) struct RuntimeModule {
  meta : ModuleInfo
  pkgs : Map[String, RuntimePackage]
}
pub impl ToJson for RuntimeModule

pub(all) struct RuntimePackage {
  name : String
  traits : Map[String, @syntax.TraitDecl]
  fn_aliases : Map[String, RuntimeValue]
  type_aliases : Map[String, WithType[@syntax.TypeDecl]]
  trait_aliases : Map[String, WithType[@syntax.TraitDecl]]
  stubs : Map[String, String]
  type_definitions : Map[String, @syntax.TypeDecl]
  type_derived_traits : Map[String, Array[String]]
  constructors : Map[String, String]
  struct_methods : Map[String, Map[String, RuntimeValue]]
  trait_methods : Map[String, Map[String, RuntimeValue]]
  values : Map[String, RuntimeValue]
  mut env : RuntimeEnvironment
  deps : Map[String, RuntimePackage]
  files : Map[String, String]
  mut loaded : Bool
}
pub fn RuntimePackage::check_type_constraint(Self, RuntimeValue, @syntax.Type) -> Bool
pub fn RuntimePackage::cons(Self, String, Array[RuntimeValue]) -> RuntimeValue
pub fn RuntimePackage::cons_with_labels(Self, String, Array[(String?, RuntimeValue, Bool)]) -> RuntimeValue
pub fn RuntimePackage::define_trait_method(Self, String, String, RuntimeValue) -> Unit
pub fn RuntimePackage::find(Self, String) -> RuntimeValue?
pub fn RuntimePackage::find_stub(Self, String) -> String
pub fn RuntimePackage::is_constructor(Self, String) -> Bool
pub fn RuntimePackage::new(String, deps? : Map[String, Self], files? : Map[String, String]) -> Self
pub fn RuntimePackage::set(Self, String, RuntimeValue) -> Unit
pub impl ToJson for RuntimePackage

pub(all) enum RuntimeType {
  Any
  Arrow(args~ : @list.List[RuntimeType], res~ : RuntimeType, err~ : RuntimeErrorType, is_async~ : Bool)
  Tuple(@list.List[RuntimeType])
  Name(pkg~ : RuntimePackage, name~ : String, tys~ : @list.List[RuntimeType])
  Option(RuntimeType)
  Object(pkg~ : RuntimePackage, name~ : String)
  Internal
}
pub fn RuntimeType::any() -> Self
pub fn RuntimeType::array() -> Self
pub fn RuntimeType::array_view() -> Self
pub fn RuntimeType::bigint() -> Self
pub fn RuntimeType::bool() -> Self
pub fn RuntimeType::byte() -> Self
pub fn RuntimeType::bytes() -> Self
pub fn RuntimeType::char() -> Self
pub fn RuntimeType::double() -> Self
pub fn RuntimeType::fixed_array() -> Self
pub fn RuntimeType::float() -> Self
pub fn RuntimeType::hashmap() -> Self
pub fn RuntimeType::int() -> Self
pub fn RuntimeType::int64() -> Self
pub fn RuntimeType::iter() -> Self
pub fn RuntimeType::json() -> Self
pub fn RuntimeType::list() -> Self
pub fn RuntimeType::map() -> Self
pub fn RuntimeType::option() -> Self
pub fn RuntimeType::result() -> Self
pub fn RuntimeType::string() -> Self
pub fn RuntimeType::string_builder() -> Self
pub fn RuntimeType::string_view() -> Self
pub fn RuntimeType::tuple() -> Self
pub fn RuntimeType::uint() -> Self
pub fn RuntimeType::uint16() -> Self
pub fn RuntimeType::uint64() -> Self
pub fn RuntimeType::uninitialized_array() -> Self
pub impl Eq for RuntimeType
pub impl Show for RuntimeType
pub impl ToJson for RuntimeType

pub(all) enum RuntimeValue {
  Unit
  Bool(Bool)
  Int(Int, raw~ : String?)
  UInt(UInt)
  UInt16(UInt16)
  Int64(Int64)
  UInt64(UInt64)
  Float(Float)
  Double(Double)
  BigInt(@bigint.BigInt)
  Char(Char)
  Byte(Byte)
  String(String)
  Bytes(Bytes)
  StringView(StringView)
  StringBuilder(StringBuilder)
  HashMap(@hashmap.HashMap[RuntimeValue, RuntimeValue])
  Tuple(Array[RuntimeValue])
  Array(Array[RuntimeValue])
  FixedArray(FixedArray[RuntimeValue])
  ArrayView(ArrayView[RuntimeValue])
  UninitializedArray(UninitializedArray[RuntimeValue])
  Map(Map[RuntimeValue, RuntimeValue])
  Object(WithType[Map[String, RuntimeValue]])
  Fn(WithType[(RuntimeFunctionContext) -> RuntimeValue raise ControlFlow])
  Constructor(WithType[ConstructorValue])
  Exception(String)
  Iter(Iter[RuntimeValue])
  Iter2(Iter2[RuntimeValue, RuntimeValue])
  Json(Json)
}
pub fn RuntimeValue::from_constant_with_type(@syntax.Constant, String?) -> Self
pub fn RuntimeValue::from_option(Self?) -> Self
pub fn RuntimeValue::from_pattern(@syntax.Pattern) -> Self
pub fn RuntimeValue::from_result(Result[Self, Self]) -> Self
pub fn RuntimeValue::is_mutable(Self) -> Bool
pub fn RuntimeValue::is_reference(Self) -> Bool
pub fn RuntimeValue::iter2(Self) -> Self
pub fn RuntimeValue::overload_array_literal(Self, String) -> Self
pub fn RuntimeValue::overload_literal(Self, String) -> Self
pub impl Add for RuntimeValue
pub impl Compare for RuntimeValue
pub impl Eq for RuntimeValue
pub impl Hash for RuntimeValue
pub impl Show for RuntimeValue
pub impl ToJson for RuntimeValue

pub struct WithType[T] {
  val : T
  ty : RuntimeType
}
pub impl[T : ToJson] ToJson for WithType[T]

// Type aliases
pub type RuntimeFunction = (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow

// Traits

