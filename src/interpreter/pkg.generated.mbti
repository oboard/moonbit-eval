// Generated using `moon info`, DON'T EDIT IT
package "oboard/moonbit-eval/interpreter"

import(
  "moonbitlang/core/bigint"
  "moonbitlang/core/hashmap"
  "moonbitlang/core/json"
  "moonbitlang/core/list"
  "moonbitlang/parser/basic"
  "moonbitlang/parser/syntax"
)

// Values
let array_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

let array_view_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

let bytes_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

fn check_type_constraint2(RuntimeType, @syntax.Type) -> Bool

fn[T : Compare] compare(T, T, String) -> @syntax.Constant

fn constant_infix(String, @syntax.Constant, @syntax.Constant) -> @syntax.Constant

#callsite(autofill(loc))
fn[A] error(String, loc~ : SourceLoc) -> A raise ControlFlow

fn eval_double_op(Double, Double, String) -> @syntax.Constant

fn eval_float_op(Double, Double, String) -> @syntax.Constant

fn eval_int64_op(Int64, Int64, String) -> @syntax.Constant

fn eval_int_op(Int, Int, String) -> @syntax.Constant

fn eval_uint64_op(UInt64, UInt64, String) -> @syntax.Constant

fn eval_uint_op(UInt, UInt, String) -> @syntax.Constant

fn extract_type_name(@syntax.Type) -> String

let fixedarray_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

let fs_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

let fs_package : RuntimePackage

let hash_map_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

let int_embedded_code : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

let int_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

fn is_comparison_op(String) -> Bool

let iter2_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

let iter_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

let map_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

let option_methods : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

fn parse_code_to_expr(String) -> Result[@syntax.Expr, String]

fn parse_code_to_impl(String) -> Result[@syntax.Impl, String]

fn runtime_value_infix(String, RuntimeValue, RuntimeValue) -> RuntimeValue

let string_embedded_code : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]

fn type_to_string(@syntax.Type) -> String

fn unit(loc? : @basic.Location) -> @syntax.Expr

// Errors
pub suberror ControlFlow {
  Raise(RuntimeValue)
  Continue(Array[RuntimeValue])
  Break(RuntimeValue)
  Return(RuntimeValue)
  Error(String)
}

// Types and methods
pub(all) struct ClosureInterpreter {
  extern_fns : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]
  embedded_fns : Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]
  embedded_methods : Map[String, Map[String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]]
  main_pkg : RuntimePackage
  mut current_pkg : RuntimePackage
  call_stack : Array[RuntimeLocation]
}
fn ClosureInterpreter::add_embedded_fn(Self, String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow) -> Unit
fn ClosureInterpreter::add_embedded_method(Self, String, String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow) -> Unit
fn ClosureInterpreter::add_extern_fn(Self, String, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow) -> Unit
fn ClosureInterpreter::bind_function_parameters(Self, @list.List[@syntax.Parameter], @list.List[RuntimeArgument]) -> Unit raise ControlFlow
fn ClosureInterpreter::call(Self, (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow, RuntimePackage, FixedArray[RuntimeArgument]) -> RuntimeValue raise ControlFlow
fn ClosureInterpreter::call_closure(Self, @syntax.Func, RuntimePackage, @list.List[@syntax.Argument], name? : String) -> RuntimeValue raise ControlFlow
fn ClosureInterpreter::constants_equal(Self, @syntax.Constant, @syntax.Constant) -> Bool
fn ClosureInterpreter::constants_equal_expr(Self, @syntax.Expr, @syntax.Expr) -> Bool
fn ClosureInterpreter::create_function(Self, @syntax.Func, RuntimePackage, name? : String) -> WithType[(RuntimeFunctionContext) -> RuntimeValue raise ControlFlow]
fn ClosureInterpreter::define_struct_method(Self, RuntimePackage, String, String, @syntax.Func) -> Unit
fn[A] ClosureInterpreter::error(Self, String) -> A raise ControlFlow
fn ClosureInterpreter::find_pkg(Self, String) -> RuntimePackage
fn ClosureInterpreter::format_patterns(Self, @list.List[@syntax.Case]) -> String
fn ClosureInterpreter::get_function_type_string(Self, @syntax.Func) -> String
fn ClosureInterpreter::infer_pattern_type(Self, @syntax.Pattern) -> String?
fn ClosureInterpreter::interp_string(Self, @list.List[@syntax.InterpElem]) -> String raise ControlFlow
fn ClosureInterpreter::is_known_function(Self, String) -> Bool
fn ClosureInterpreter::load_module(Self, RuntimeModule) -> Unit
fn ClosureInterpreter::load_package(Self, RuntimePackage, target? : String) -> Unit
fn ClosureInterpreter::lookup_current_function(Self) -> String
fn ClosureInterpreter::match_case(Self, RuntimeValue, @syntax.Pattern) -> Bool
fn ClosureInterpreter::new() -> Self
fn ClosureInterpreter::parse_error_type(Self, @syntax.ErrorType) -> RuntimeErrorType
fn ClosureInterpreter::parse_type(Self, @syntax.Type) -> RuntimeType
fn ClosureInterpreter::pattern_match(Self, RuntimeValue, @list.List[@syntax.Case]) -> RuntimeValue raise ControlFlow
fn ClosureInterpreter::pattern_to_runtime_value(Self, @syntax.Pattern) -> RuntimeValue?
fn ClosureInterpreter::pop_scope(Self) -> Unit
fn ClosureInterpreter::push_scope(Self, RuntimeLocation) -> Unit
fn ClosureInterpreter::runtime_value_in_range(Self, RuntimeValue, @syntax.Pattern, @syntax.Pattern, Bool) -> Bool
fn ClosureInterpreter::top_eval(Self, String) -> Unit
fn ClosureInterpreter::top_func_def_to_closure(Self, RuntimePackage, @syntax.Impl, name? : String) -> (String?, RuntimeValue)
fn ClosureInterpreter::top_visit(Self, @syntax.Impl) -> RuntimeValue
fn ClosureInterpreter::visit(Self, @syntax.Expr, expected_type? : String) -> RuntimeValue raise ControlFlow
fn ClosureInterpreter::visit_interp(Self, @list.List[@syntax.InterpElem]) -> RuntimeValue raise ControlFlow
fn ClosureInterpreter::visit_multiline_string(Self, @list.List[@syntax.MultilineStringElem]) -> RuntimeValue raise ControlFlow
fn ClosureInterpreter::visit_scoped(Self, @syntax.Expr, RuntimeLocation) -> RuntimeValue raise ControlFlow
fn[T] ClosureInterpreter::with_ident(Self, @syntax.LongIdent, (RuntimePackage, String) -> T raise?) -> T raise?

pub(all) struct ConstructorField {
  name : String?
  mut value : RuntimeValue
  mutable : Bool
}

pub(all) struct ConstructorValue {
  name : String
  fields : Array[ConstructorField]
}

pub(all) struct ModuleInfo {
  name : String
  version : String?
  deps : Map[String, String]?
  readme : String?
  repository : String?
  license : String?
  keywords : Array[String]?
  description : String?
  source : String?
}
fn ModuleInfo::from_json(Json, @json.JsonPath) -> Self raise @json.JsonDecodeError // from trait `@json.FromJson`
async fn ModuleInfo::get_zip_url(Self) -> String noraise
fn ModuleInfo::new(String, version? : String, readme? : String, repository? : String, license? : String, keywords? : Array[String], description? : String, source? : String, deps? : Map[String, String]) -> Self
fn ModuleInfo::output(Self, &Logger) -> Unit // from trait `Show`
fn ModuleInfo::to_json(Self) -> Json // from trait `ToJson`
fn ModuleInfo::to_string(Self) -> String // from trait `Show`
impl Show for ModuleInfo
impl ToJson for ModuleInfo
impl @json.FromJson for ModuleInfo

pub(all) struct RuntimeArgument {
  val : RuntimeValue
  kind : RuntimeArgumentKind
}

pub(all) enum RuntimeArgumentKind {
  Positional
  Labelled(String)
  LabelledOption(String)
}
fn RuntimeArgumentKind::from_syntax(@syntax.ArgumentKind) -> Self

pub(all) struct RuntimeEnvironment {
  values : Map[String, RuntimeValue]
  mutable_vars : Map[String, Bool]
  parent : RuntimeEnvironment?
}
fn RuntimeEnvironment::copy(Self) -> Self
fn RuntimeEnvironment::create_closure_env(Self) -> Self
fn RuntimeEnvironment::find(Self, String) -> RuntimeValue?
fn RuntimeEnvironment::new(parent? : Self, values? : Map[String, RuntimeValue]) -> Self
fn RuntimeEnvironment::set(Self, String, RuntimeValue) -> Unit
fn RuntimeEnvironment::set_mutable_variable(Self, String, RuntimeValue) -> Unit
fn RuntimeEnvironment::to_json(Self) -> Json // from trait `ToJson`
fn RuntimeEnvironment::update(Self, String, RuntimeValue) -> Unit
impl ToJson for RuntimeEnvironment

pub(all) enum RuntimeErrorType {
  ErrorType(RuntimeType)
  DefaultErrorType
  NoErrorType
  Noraise
  MaybeError(RuntimeType)
}
fn RuntimeErrorType::equal(Self, Self) -> Bool // from trait `Eq`
#deprecated
fn RuntimeErrorType::op_equal(Self, Self) -> Bool // from trait `Eq`
fn RuntimeErrorType::output(Self, &Logger) -> Unit // from trait `Show`
fn RuntimeErrorType::to_json(Self) -> Json // from trait `ToJson`
fn RuntimeErrorType::to_string(Self) -> String // from trait `Show`
impl Eq for RuntimeErrorType
impl Show for RuntimeErrorType
impl ToJson for RuntimeErrorType

pub(all) struct RuntimeFunctionContext {
  context : ClosureInterpreter
  pkg : RuntimePackage
  args : FixedArray[RuntimeArgument]
}
fn RuntimeFunctionContext::named(Self, String) -> RuntimeValue?

pub enum RuntimeLocation {
  FunctionCall(String)
  ControlFlow(String)
  LetMut(String)
}
fn RuntimeLocation::output(Self, &Logger) -> Unit // from trait `Show`
fn RuntimeLocation::to_string(Self) -> String // from trait `Show`
impl Show for RuntimeLocation

pub(all) struct RuntimeModule {
  meta : ModuleInfo
  pkgs : Map[String, RuntimePackage]
}
fn RuntimeModule::to_json(Self) -> Json // from trait `ToJson`
impl ToJson for RuntimeModule

pub(all) struct RuntimePackage {
  name : String
  traits : Map[String, @syntax.TraitDecl]
  fn_aliases : Map[String, RuntimeValue]
  type_aliases : Map[String, WithType[@syntax.TypeDecl]]
  trait_aliases : Map[String, WithType[@syntax.TraitDecl]]
  stubs : Map[String, String]
  type_definitions : Map[String, @syntax.TypeDecl]
  type_derived_traits : Map[String, Array[String]]
  constructors : Map[String, String]
  struct_methods : Map[String, Map[String, RuntimeValue]]
  trait_methods : Map[String, Map[String, RuntimeValue]]
  values : Map[String, RuntimeValue]
  mut env : RuntimeEnvironment
  deps : Map[String, RuntimePackage]
  files : Map[String, String]
  mut loaded : Bool
}
fn RuntimePackage::check_type_constraint(Self, RuntimeValue, @syntax.Type) -> Bool
fn RuntimePackage::cons(Self, String, Array[RuntimeValue]) -> RuntimeValue
fn RuntimePackage::cons_with_labels(Self, String, Array[(String?, RuntimeValue, Bool)]) -> RuntimeValue
fn RuntimePackage::define_trait_method(Self, String, String, RuntimeValue) -> Unit
fn RuntimePackage::find(Self, String) -> RuntimeValue?
fn RuntimePackage::find_stub(Self, String) -> String
fn RuntimePackage::is_constructor(Self, String) -> Bool
fn RuntimePackage::new(String, deps? : Map[String, Self], files? : Map[String, String]) -> Self
fn RuntimePackage::set(Self, String, RuntimeValue) -> Unit
fn RuntimePackage::to_json(Self) -> Json // from trait `ToJson`
impl ToJson for RuntimePackage

pub(all) enum RuntimeType {
  Any
  Arrow(args~ : @list.List[RuntimeType], res~ : RuntimeType, err~ : RuntimeErrorType, is_async~ : Bool)
  Tuple(@list.List[RuntimeType])
  Name(pkg~ : RuntimePackage, name~ : String, tys~ : @list.List[RuntimeType])
  Option(RuntimeType)
  Object(pkg~ : RuntimePackage, name~ : String)
  Internal
}
fn RuntimeType::any() -> Self
fn RuntimeType::array() -> Self
fn RuntimeType::array_view() -> Self
fn RuntimeType::bigint() -> Self
fn RuntimeType::bool() -> Self
fn RuntimeType::byte() -> Self
fn RuntimeType::bytes() -> Self
fn RuntimeType::char() -> Self
fn RuntimeType::double() -> Self
fn RuntimeType::equal(Self, Self) -> Bool // from trait `Eq`
fn RuntimeType::fixed_array() -> Self
fn RuntimeType::float() -> Self
fn RuntimeType::hashmap() -> Self
fn RuntimeType::int() -> Self
fn RuntimeType::int64() -> Self
fn RuntimeType::iter() -> Self
fn RuntimeType::json() -> Self
fn RuntimeType::list() -> Self
fn RuntimeType::map() -> Self
#deprecated
fn RuntimeType::op_equal(Self, Self) -> Bool // from trait `Eq`
fn RuntimeType::option() -> Self
fn RuntimeType::output(Self, &Logger) -> Unit // from trait `Show`
fn RuntimeType::result() -> Self
fn RuntimeType::string() -> Self
fn RuntimeType::string_builder() -> Self
fn RuntimeType::string_view() -> Self
fn RuntimeType::to_json(Self) -> Json // from trait `ToJson`
fn RuntimeType::to_string(Self) -> String // from trait `Show`
fn RuntimeType::tuple() -> Self
fn RuntimeType::uint() -> Self
fn RuntimeType::uint16() -> Self
fn RuntimeType::uint64() -> Self
fn RuntimeType::uninitialized_array() -> Self
impl Eq for RuntimeType
impl Show for RuntimeType
impl ToJson for RuntimeType

pub(all) enum RuntimeValue {
  Unit
  Bool(Bool)
  Int(Int)
  UInt(UInt)
  UInt16(UInt16)
  Int64(Int64)
  UInt64(UInt64)
  Float(Float)
  Double(Double)
  BigInt(@bigint.BigInt)
  Char(Char)
  Byte(Byte)
  String(String)
  Bytes(Bytes)
  StringView(StringView)
  StringBuilder(StringBuilder)
  HashMap(@hashmap.HashMap[RuntimeValue, RuntimeValue])
  Tuple(Array[RuntimeValue])
  Array(Array[RuntimeValue])
  FixedArray(FixedArray[RuntimeValue])
  ArrayView(ArrayView[RuntimeValue])
  UninitializedArray(UninitializedArray[RuntimeValue])
  Map(Map[RuntimeValue, RuntimeValue])
  Object(WithType[Map[String, RuntimeValue]])
  Fn(WithType[(RuntimeFunctionContext) -> RuntimeValue raise ControlFlow])
  Constructor(WithType[ConstructorValue])
  Exception(String)
  Iter(Iter[RuntimeValue])
  Iter2(Iter2[RuntimeValue, RuntimeValue])
  Json(Json)
}
fn RuntimeValue::add(Self, Self) -> Self // from trait `Add`
fn RuntimeValue::compare(Self, Self) -> Int // from trait `Compare`
fn RuntimeValue::equal(Self, Self) -> Bool // from trait `Eq`
fn RuntimeValue::from_constant_with_type(@syntax.Constant, String?) -> Self
fn RuntimeValue::from_option(Self?) -> Self
fn RuntimeValue::from_pattern(@syntax.Pattern) -> Self
fn RuntimeValue::from_result(Result[Self, Self]) -> Self
fn RuntimeValue::hash(Self) -> Int // from trait `Hash`
fn RuntimeValue::hash_combine(Self, Hasher) -> Unit // from trait `Hash`
fn RuntimeValue::is_mutable(Self) -> Bool
fn RuntimeValue::is_reference(Self) -> Bool
fn RuntimeValue::iter2(Self) -> Self
#deprecated
fn RuntimeValue::op_add(Self, Self) -> Self // from trait `Add`
#deprecated
fn RuntimeValue::op_equal(Self, Self) -> Bool // from trait `Eq`
fn RuntimeValue::output(Self, &Logger) -> Unit // from trait `Show`
fn RuntimeValue::overload_array_literal(Self, String) -> Self
fn RuntimeValue::overload_literal(Self, String) -> Self
fn RuntimeValue::to_json(Self) -> Json // from trait `ToJson`
fn RuntimeValue::to_string(Self) -> String // from trait `Show`
impl Add for RuntimeValue
impl Compare for RuntimeValue
impl Eq for RuntimeValue
impl Hash for RuntimeValue
impl Show for RuntimeValue
impl ToJson for RuntimeValue

pub struct WithType[T] {
  val : T
  ty : RuntimeType
}
fn[T : ToJson] WithType::to_json(Self[T]) -> Json // from trait `ToJson`
impl[T : ToJson] ToJson for WithType[T]

// Type aliases
pub typealias (RuntimeFunctionContext) -> RuntimeValue raise ControlFlow as RuntimeFunction

// Traits

